#!/bin/bash

set -e

BASEDIR="$(readlink -f $(dirname "$0"))"
PROFILE="$1"
EPOCH=$(date +%s)
readonly BASEDIR PROFILE EPOCH

# log-related functions {{{
log () {
    local mesg=$1; shift
    if [ -f "$GLOBAL_LOG" ]; then
        date --iso-8601=seconds | tr -d "\n" >> $GLOBAL_LOG
        printf " ${mesg}\n" "$@" >> $GLOBAL_LOG
    fi
}

panick () {
    local mesg=$1; shift
    local str=$(printf "==> ERROR: ${mesg}\n" "$@")
    log "$str"; echo $str >&2
    exit 1
}

msg() {
    local mesg=$1; shift
    local str=$(printf "==> ${mesg}\n" "$@")
    log "$str"; echo $str
}
# }}}

check_subvolume () {
    local subvol=$1

    if [ -d "$subvol" ]; then
        btrfs subvol show $subvol >/dev/null 2>&1
        if [ $? -ne 0 ]; then
            panick "$subvol exist but not a btrfs subvolume!"
        fi
    else
        btrfs subvolume create $subvol \
            || panick "Failed to create subvolume $subvol"
    fi
}

parse_profile () {
    local common_conf="${BASEDIR}/common.conf"
    local profile_conf="${BASEDIR}/profiles/${PROFILE}.conf"

    declare -g -A conf

    if [ -f $profile_conf ]; then
        while read line; do
            local key=${line%%=*} value=${line#*=}
            conf[$key]="$value"
        done < <( \
            [ -f "$common_conf" ] && cat "$common_conf"
            cat $profile_conf
        )
    else
        panick "Backup profile not found!"
    fi

    fallback_conf () {
        local key=$1 value=$2
        conf["$1"]=${conf["$1"]:-"$2"}
    }

    fallback_conf SSH_KEY "${BASEDIR}/keys/${conf[USER]}@${conf[SERVER]}"
    fallback_conf LOG_DIR "${BASEDIR}/log/${PROFILE}/"
    fallback_conf RSYNC_OPTS '-aHAX --timeout 3600 --delete'
    fallback_conf KEEP_DAYS 30
    fallback_conf KEEP_LONG_COUNT 4
}

init_log () {
    local log_dir=$1

    GLOBAL_LOG="${log_dir}/backup.log.${EPOCH}"
    RSYNC_LOG="${log_dir}/rsync.log.${EPOCH}"

    touch "$GLOBAL_LOG"
    log "Script start at %s" "$(date --date=@$EPOCH --iso-8601=seconds)"
}

check_and_prepare () {
    # initialize log
    [ -d ${conf["LOG_DIR"]} ] || mkdir ${conf["LOG_DIR"]}
    init_log ${conf["LOG_DIR"]}

    # these variable are demanded and no fallback
    for key in 'SERVER' 'USER' 'SRC' 'STORAGE'; do
        [ -z ${conf[$key]} ] && panick "Backup profile invalid!"
    done

    # SSH key must be provided to login remote
    [ -f "${conf["SSH_KEY"]}" ] || panick "SSH key not found!"

    # must be root to continue
    [[ $(whoami) != 'root' ]] && panick "Please run as root!"

    if [[ $(stat -f -c %T "${conf[STORAGE]}") != "btrfs" ]]; then
        panick "Backup storage is not on a btrfs partition!"
    else
        local sync_to="${conf[STORAGE]}/${PROFILE}"
        check_subvolume "${sync_to}"
        check_subvolume "${sync_to}/current"
    fi

    # some shortcut global variables
    RSH_OPTS="ssh -i ${conf[SSH_KEY]}"
    KEEP_SECONDS="$((conf[KEEP_DAYS]*86400))"
    SYNC_TO="$sync_to"
    SYNC_TO_CURRENT="${sync_to}/current"
}

list_snapshots () {
    local subvol=$1
    btrfs sub show $1 \
        | awk 'f;/\tSnapshot\(s\):/{f=1}' \
        | while read s; do echo ${s##*/}; done \
        | sort -t_ -k2 -n
}

make_snapshot () {
    local lastest_l_snap=$(list_snapshots "$SYNC_TO_CURRENT" \
                                | grep "^L_" | tail -n1)
    lastest_l_snap=${lastest_l_snap:-"L_0"}

    if [ $((${lastest_l_snap#L_}+${KEEP_SECONDS})) -lt $(date +%s) ] \
        && [ ${conf[KEEP_LONG_COUNT]} -gt 0 ]; then
        msg "Create long-live backup: %s" "L_$EPOCH"
        btrfs subvol snapshot -r "$SYNC_TO_CURRENT" "${SYNC_TO}/L_$EPOCH"
    else
        msg "Create short-live backup: %s" "S_$EPOCH"
        btrfs subvol snapshot -r "$SYNC_TO_CURRENT" "${SYNC_TO}/S_$EPOCH"
    fi
}

clean_snapshots () {
    # Clean long-time snapshots
    list_snapshots "$SYNC_TO_CURRENT" | grep "L_" \
        | head -n-${conf[KEEP_LONG_COUNT]} \
            | while read subvol; do
        msg "Delete old backup ${subvol}"
        btrfs subvolume delete "${SYNC_TO}/${subvol}"
    done

    # Clean short-time snapshots
    list_snapshots "$SYNC_TO_CURRENT" | grep "S_" | while read subvol; do
        if [ ${subvol#S_} -lt $((EPOCH-$KEEP_SECONDS)) ]; then
            msg "Delete old backup ${subvol}"
            btrfs subvolume delete "${SYNC_TO}/${subvol}"
        fi
    done
}

# main {{{
parse_profile 
check_and_prepare

rsync -e "$RSH_OPTS" ${conf[RSYNC_OPTS]} --log-file "$RSYNC_LOG" \
         "${conf[USER]}@${conf[SERVER]}:${conf[SRC]}/" "$SYNC_TO_CURRENT"

make_snapshot
clean_snapshots
# }}}

